#!/usr/bin/env python3
"""
QUANTUM TRADER - VERSIONE HEARTBEAT
Auto-recovery + monitoring continuo
"""
import requests
import logging
import time
import sqlite3
import os
import sys
from datetime import datetime
import numpy as np

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('production.log', mode='a', encoding='utf-8'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger("QuantumHeartbeat")

class HeartbeatTrader:
    def __init__(self):
        self.base_url = "https://api.binance.com"
        self.symbols = ["BTCUSDT", "ETHUSDT", "SOLUSDT", "BNBUSDT", "XRPUSDT", "ADAUSDT"]
        
        self.min_confluence = 2.6
        self.min_confidence = 0.70
        self.max_risk_per_trade = 0.07
        
        # INIZIALIZZA CON PORTFOLIO ESISTENTE
        self.virtual_balance = 10000.0
        self.available_balance = 9300.0
        self.portfolio = {"XRPUSDT": 260.233 + 241.971 + 259.856}
        self.trade_count = 3
        
        logger.info("ðŸš€ HEARTBEAT TRADER INIZIALIZZATO")
        logger.info(f"ðŸ’° Balance: ${self.available_balance:.2f}")
        logger.info(f"ðŸ“¦ Portfolio: {self.portfolio}")

    def heartbeat(self, message):
        """Log heartbeat per tracciare vitalitÃ """
        logger.info(f"â¤ï¸  {message}")

    def safe_sleep(self, seconds):
        """Sleep con heartbeat per evitare crash"""
        chunks = seconds // 30  # Sleep in chunks di 30 secondi
        for i in range(chunks):
            self.heartbeat(f"Sleep... {i+1}/{chunks}")
            time.sleep(30)
        
        remaining = seconds % 30
        if remaining > 0:
            time.sleep(remaining)

    def get_real_price(self, symbol: str) -> float:
        try:
            self.heartbeat(f"Get price {symbol}")
            url = f"{self.base_url}/api/v3/ticker/price"
            params = {'symbol': symbol}
            response = requests.get(url, params=params, timeout=10)
            return float(response.json()['price']) if response.status_code == 200 else 0.0
        except Exception as e:
            logger.error(f"âŒ Price error {symbol}: {e}")
            return 0.0

    def analyze_macro(self) -> tuple:
        """Analisi macro basata su prezzo BTC reale"""
        self.heartbeat("Analisi macro")
        try:
            btc_price = self.get_real_price("BTCUSDT")
            
            # Score basato sul prezzo BTC
            if btc_price > 100000:
                score = 0.85  # Molto bullish
            elif btc_price > 80000:
                score = 0.75  # Bullish
            elif btc_price > 60000:
                score = 0.65  # Neutrale
            else:
                score = 0.50  # Cautela
            
            return score, f"BTC ${btc_price:,.0f}"
        except:
            return 0.5, "Errore macro"

    def analyze_price_action(self, symbol: str) -> tuple:
        """Analisi price action con dati reali da Binance"""
        self.heartbeat(f"Price action {symbol}")
        try:
            import requests
            url = f"{self.base_url}/api/v3/ticker/24hr"
            response = requests.get(url, params={'symbol': symbol}, timeout=5)
            
            if response.status_code == 200:
                data = response.json()
                change_24h = float(data['priceChangePercent'])
                
                # Calcola score basato su momentum
                if change_24h > 5:
                    score = 0.9
                elif change_24h > 2:
                    score = 0.75
                elif change_24h > 0:
                    score = 0.6
                elif change_24h > -2:
                    score = 0.5
                elif change_24h > -5:
                    score = 0.4
                else:
                    score = 0.3
                
                return score, f"24h: {change_24h:+.2f}%"
            else:
                return 0.5, "API error"
                
        except Exception as e:
            return 0.5, f"Error: {str(e)[:20]}"

    def analyze_onchain(self, symbol: str) -> tuple:
        """Analisi on-chain semplificata"""
        self.heartbeat(f"On-chain {symbol}")
        try:
            price = self.get_real_price(symbol)
            
            # Score basato sul prezzo (esempio semplificato)
            if symbol == "BTCUSDT":
                score = 0.7 if price > 100000 else 0.5
            elif symbol == "ETHUSDT":
                score = 0.65 if price > 3500 else 0.5
            elif symbol == "SOLUSDT":
                score = 0.6 if price > 150 else 0.5
            else:
                score = 0.55
            
            return score, "On-chain OK"
        except:
            return 0.5, "On-chain test"

    def analyze_cycles(self) -> tuple:
        """Analisi cicli con variazione temporale"""
        self.heartbeat("Analisi cicli")
        try:
            # Halving BTC: Aprile 2024
            halving_date = datetime(2024, 4, 20)
            days_since = (datetime.now() - halving_date).days
            
            # Score basato sulla posizione nel ciclo
            if days_since < 365:
                score = 0.5 + (days_since / 365) * 0.2  # 0.5 -> 0.7
            elif days_since < 730:
                score = 0.7 + ((days_since - 365) / 365) * 0.2  # 0.7 -> 0.9
            elif days_since < 1095:
                score = 0.9 - ((days_since - 730) / 365) * 0.3  # 0.9 -> 0.6
            else:
                score = 0.6 - ((days_since - 1095) / 365) * 0.2  # 0.6 -> 0.4
            
            return round(score, 2), f"{days_since} giorni post-halving"
        except:
            return 0.55, "556 giorni post-halving"


    def calculate_confluence(self, symbol: str) -> dict:
        self.heartbeat(f"Confluence {symbol}")
        
        macro_score, macro_reason = self.analyze_macro()
        price_score, price_reason = self.analyze_price_action(symbol)
        onchain_score, onchain_reason = self.analyze_onchain(symbol)
        cycles_score, cycles_reason = self.analyze_cycles()
        
        weights = [0.30, 0.30, 0.25, 0.15]
        confluence = sum(s * w for s, w in zip([macro_score, price_score, onchain_score, cycles_score], weights))
        
        signal = "HOLD"
        if symbol == "XRPUSDT":
            self.heartbeat("ðŸš« XRP bloccato - overconcentration")
        
        return {
            'symbol': symbol,
            'confluence': confluence * 4,
            'confidence': confluence,
            'signal': signal,
            'price': self.get_real_price(symbol)
        }

    def run_trading_cycle(self, cycle_num: int):
        """Ciclo di trading con heartbeat"""
        self.heartbeat(f"INIZIO CICLO #{cycle_num}")
        
        try:
            # Portfolio snapshot
            portfolio_value = self.available_balance
            for asset, qty in self.portfolio.items():
                price = self.get_real_price(asset)
                portfolio_value += qty * price
            
            self.heartbeat(f"Portfolio: ${portfolio_value:.2f}")
            
            # Analisi symbols
            for symbol in self.symbols:
                analysis = self.calculate_confluence(symbol)
                self.heartbeat(f"{symbol}: {analysis['signal']} (Score: {analysis['confluence']:.2f})")
            
            self.heartbeat(f"FINE CICLO #{cycle_num}")
            return True
            
        except Exception as e:
            logger.error(f"ðŸ’¥ CICLO #{cycle_num} CRASH: {e}")
            return False

    def run(self):
        """Loop principale con recovery integrata"""
        self.heartbeat("START HEARTBEAT TRADER")
        cycle_count = 0
        max_cycles = 50
        
        while cycle_count < max_cycles:
            try:
                cycle_count += 1
                success = self.run_trading_cycle(cycle_count)
                
                if not success:
                    logger.warning("ðŸ”„ Ciclo fallito, ma continuo...")
                
                # âš ï¸ SLEEP SICURO con heartbeat
                self.heartbeat(f"Attesa 60s prima del prossimo ciclo... ({cycle_count}/{max_cycles})")
                self.safe_sleep(300)  # Solo 1 minuto per test
                
            except KeyboardInterrupt:
                self.heartbeat("ðŸ›‘ Fermato dall'utente")
                break
            except Exception as e:
                logger.error(f"ðŸ’¥ ERRORE GLOBALE: {e}")
                self.heartbeat("ðŸ”„ Ripristino tra 30s...")
                time.sleep(30)
        
        self.heartbeat("ðŸ SIMULAZIONE COMPLETATA")

if __name__ == "__main__":
    trader = HeartbeatTrader()
    trader.run()
